Obfuscating Cookie Data:

-- Generate Remember Tokens:
	+ Create our own rand package that wraps around Go's crypto/rand package so
		we have a quick way, and one place, to create secure randomized strings
		we need without worry and have the ability to test
		-- be sure you are using crypto/rand for this package, not the math one,
			as it is based on a cryptographically strong pseudo-random generator
	+ Use the crypto/rand Read function to generate random []byte:
		func Read(b []byte) (n int, err error)
		-- Read function works by taking in a byte slice and filling it with 
			random values. It then returns two values: an integer and an error.
		-- The integer will be equal to the length of the byte slice if there 
			weren’t any errors, but it could be smaller if there was an error. 
			In that case it represents how many bytes were written before there
			was an error.
		-- This function will help us generate n random bytes, or will return an
			error if there was one

		func Bytes(n int) ([]byte, error) {
			b := make([]byte, n)
			_, err := rand.Read(b)
			if err != nil {
				return nil, err
			}
			return b, nil
		}
	+ Use encoding/base64 to change []byte into a string:
		-- When we generate a random byte slice using the crypto/rand package it
			isn’t guaranteed that every byte will map to a valid UTF-8 character. 
		-- When this happens you would get what looks like invalid characters in
			your string and it might not be persisted correctly in cookies and 
			some databases.
		-- Means we can’t simply convert our random byte slice generated by the
			Read function into a string using normal conversion (string([]byte)).
		-- Instead we need to use an encoding scheme that will take arbitrary 
			binary data (like our byte slice) and encode it as a string correctly.
		-- We will fill a byte slice with random data (Bytes function), then
			encode that byte slice as a string (String function), then use that
			string for our remember token/cookie
		-- Using the URL Encoding because it's one of the safest options when
			you don't need a specific encoding

		func String(nBytes int) (string, error) {
			b, err := Bytes(nBytes)
			if err != nil {
				return "", err
			}
			return base64.URLEncoding.EncodeToString(b), nil
		}
	+ Create RememberToken function:
		-- Use a constant number of bytes to feed into the String function so
			that devs don't need to remember how many bytes they need in the
			remember tokens
		-- This function is a helper function designed to generate remember 
			tokens of a predetermined (const) byte size.

		const RememberTokenBytes = 32

		func RememberToken() (string, error){
			return String(RememberTokenBytes)
		}
-- Using 32 bytes for generating token:
	+ There are 256 unique tokens available per byte
	+ 256 ^ 32 = 1e77 unquie tokens available for our remember tokens
	+ We pick a very large set of tokens that are available to users, and that
		also makes it harder for attackers to randomly guess a remember token
		quickly